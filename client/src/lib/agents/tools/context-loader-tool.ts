// src/lib/agents/tools/context-loader-tool.ts
import path from "node:path";

import { BaseTool, ToolParameter, ToolResult, ToolContext } from "./base-tool";
import { SandboxService } from "@/lib/services/sandbox-service";
import { logger } from "@/lib/logger";

// ✅ INCREASED LIMIT: 200 -> 2000 to ensure full codebase visibility
const MAX_SCAN_RESULTS = 2000;

// ✅ IMPROVED EXCLUSIONS: Added common junk folders
const EXCLUDED_PATHS = [
  "*/node_modules/*",
  "*/.git/*",
  "*/dist/*",
  "*/build/*",
  "*/.next/*",
  "*/coverage/*",
  "*/.vscode/*",
  "*/.idea/*",
  "*/public/sw.js", // Often large/autogenerated
  "*/package-lock.json", // Too large to read
  "*/yarn.lock",
  "*/pnpm-lock.yaml",
];

type ContextOperation =
  | "scan_structure"
  | "load_files"
  | "load_dependencies"
  | "load_config"
  | "smart_load";

type ParseResult<T> = { ok: true; value: T } | { ok: false; error: string };

interface ContextParams {
  operation: ContextOperation;
  paths?: string[];
  pattern?: string;
  taskDescription?: string;
  maxFiles: number;
  maxSize: number;
}

interface FileSummary {
  path: string;
  size: number;
  type: string;
}

interface ProjectStructure {
  directories: string[];
  files: FileSummary[];
  totalFiles: number;
  totalSize: number;
}

interface DependenciesSummary {
  packages: Array<{ name: string; version?: string }>;
  devPackages: Array<{ name: string; version?: string }>;
}

interface ConfigurationSummary {
  packageJson?: Record<string, unknown>;
  tsconfig?: Record<string, unknown>;
  eslintrc?: Record<string, unknown>;
  gitignore?: string[];
}

interface LoadedFile {
  path: string;
  content: string;
  size: number;
}

export class ContextLoaderTool extends BaseTool {
  name = "context_loader";
  description =
    "Load project structure, dependencies, and relevant files into context";

  parameters: ToolParameter[] = [
    {
      name: "operation",
      type: "string",
      description:
        'Operation: "scan_structure", "load_files", "load_dependencies", "load_config", "smart_load"',
      required: true,
    },
    {
      name: "paths",
      type: "array",
      description: "Specific paths to load (optional)",
      required: false,
    },
    {
      name: "pattern",
      type: "string",
      description: "File pattern to match (e.g., '*.ts', 'api/**/*.ts')",
      required: false,
    },
    {
      name: "taskDescription",
      type: "string",
      description: "Task description to determine relevant files",
      required: false,
    },
    {
      name: "maxFiles",
      type: "number",
      description: "Maximum number of files to load (default: 50)",
      required: false,
      default: 50,
    },
    {
      name: "maxSize",
      type: "number",
      description: "Maximum total size in bytes (default: 1MB)",
      required: false,
      default: 1_048_576,
    },
  ];

  async execute(
    params: Record<string, unknown>,
    context: ToolContext
  ): Promise<ToolResult> {
    const parsedParams = this.parseParams(params);
    if (!parsedParams.ok) {
      return { success: false, error: parsedParams.error };
    }

    const { projectId, userId } = context;
    const { operation, paths, pattern, taskDescription, maxFiles, maxSize } =
      parsedParams.value;

    try {
      this.logExecution("Context loading", { operation, maxFiles });

      switch (operation) {
        case "scan_structure":
          return await this.scanStructure(projectId, userId);
        case "load_files":
          return await this.loadFiles(
            projectId,
            userId,
            paths ?? [],
            maxFiles,
            maxSize
          );
        case "load_dependencies":
          return await this.loadDependencies(projectId, userId);
        case "load_config":
          return await this.loadConfiguration(projectId, userId);
        case "smart_load":
          return await this.smartLoad(
            projectId,
            userId,
            pattern,
            taskDescription,
            maxFiles,
            maxSize
          );
        default:
          return { success: false, error: "Unhandled operation" };
      }
    } catch (error) {
      this.logError("Context loading", error);
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  }

  private parseParams(
    raw: Record<string, unknown>
  ): ParseResult<ContextParams> {
    const operationValue = raw.operation;
    if (typeof operationValue !== "string") {
      return { ok: false, error: "Missing required operation" };
    }

    const normalizedOperation = operationValue.toLowerCase();
    if (!this.isSupportedOperation(normalizedOperation)) {
      return { ok: false, error: `Unknown operation: ${operationValue}` };
    }

    let paths: string[] | undefined;
    if (Array.isArray(raw.paths)) {
      const sanitized = raw.paths
        .filter((item): item is string => typeof item === "string")
        .map((item) => item.trim())
        .filter((item) => item.length > 0);
      if (sanitized.length > 0) {
        paths = Array.from(new Set(sanitized));
      }
    }

    const pattern =
      typeof raw.pattern === "string" ? raw.pattern.trim() : undefined;
    const taskDescription =
      typeof raw.taskDescription === "string"
        ? raw.taskDescription.trim()
        : undefined;

    const maxFiles =
      typeof raw.maxFiles === "number" && Number.isFinite(raw.maxFiles)
        ? Math.max(1, Math.floor(raw.maxFiles))
        : 50;
    const maxSize =
      typeof raw.maxSize === "number" && Number.isFinite(raw.maxSize)
        ? Math.max(1, Math.floor(raw.maxSize))
        : 1_048_576;

    return {
      ok: true,
      value: {
        operation: normalizedOperation,
        paths,
        pattern: pattern && pattern.length > 0 ? pattern : undefined,
        taskDescription:
          taskDescription && taskDescription.length > 0
            ? taskDescription
            : undefined,
        maxFiles,
        maxSize,
      },
    };
  }

  private isSupportedOperation(value: string): value is ContextOperation {
    return (
      value === "scan_structure" ||
      value === "load_files" ||
      value === "load_dependencies" ||
      value === "load_config" ||
      value === "smart_load"
    );
  }

  private async scanStructure(
    projectId: string,
    userId: string
  ): Promise<ToolResult> {
    const filesResult = await this.listProjectFiles(projectId, userId);
    if (!filesResult.ok) {
      return { success: false, error: filesResult.error };
    }

    const structure = this.buildStructure(filesResult.value);
    return {
      success: true,
      data: {
        structure,
        filesByType: this.groupFilesByType(filesResult.value),
      },
    };
  }

  private async loadFiles(
    projectId: string,
    userId: string,
    paths: string[],
    maxFiles: number,
    maxSize: number
  ): Promise<ToolResult> {
    if (paths.length === 0) {
      return { success: false, error: "No file paths provided" };
    }

    const loadedFiles: LoadedFile[] = [];
    let totalSize = 0;

    for (const filePath of paths) {
      if (loadedFiles.length >= maxFiles) {
        break;
      }

      const fileResult = await this.readWorkspaceFile(
        projectId,
        userId,
        filePath
      );
      if (!fileResult.ok) {
        logger.warn(`Failed to load file ${filePath}: ${fileResult.error}`);
        continue;
      }

      const size = Buffer.byteLength(fileResult.value, "utf8");
      if (totalSize + size > maxSize) {
        break;
      }

      loadedFiles.push({
        path: filePath,
        content: fileResult.value,
        size,
      });
      totalSize += size;
    }

    return {
      success: true,
      data: {
        files: loadedFiles,
        totalSize,
      },
    };
  }

  private async loadDependencies(
    projectId: string,
    userId: string
  ): Promise<ToolResult> {
    const packageJson = await this.loadJsonFile(
      projectId,
      userId,
      "package.json"
    );
    if (!packageJson) {
      return {
        success: false,
        error: "package.json not found or could not be parsed",
      };
    }

    return {
      success: true,
      data: {
        dependencies: this.extractDependencies(packageJson),
      },
    };
  }

  private async loadConfiguration(
    projectId: string,
    userId: string
  ): Promise<ToolResult> {
    const packageJson = await this.loadJsonFile(
      projectId,
      userId,
      "package.json"
    );
    const tsconfig = await this.loadJsonFile(
      projectId,
      userId,
      "tsconfig.json"
    );
    const eslintConfig =
      (await this.loadJsonFile(projectId, userId, ".eslintrc.json")) ??
      (await this.loadJsonFile(projectId, userId, ".eslintrc"));
    const gitignoreContent = await this.readWorkspaceFile(
      projectId,
      userId,
      ".gitignore"
    );

    return {
      success: true,
      data: {
        configuration: {
          packageJson: packageJson ?? undefined,
          tsconfig: tsconfig ?? undefined,
          eslintrc: eslintConfig ?? undefined,
          gitignore: gitignoreContent.ok
            ? gitignoreContent.value
                .split("\n")
                .map((line) => line.trim())
                .filter((line) => line.length > 0)
            : undefined,
        } satisfies ConfigurationSummary,
      },
    };
  }

  private async smartLoad(
    projectId: string,
    userId: string,
    pattern: string | undefined,
    taskDescription: string | undefined,
    maxFiles: number,
    maxSize: number
  ): Promise<ToolResult> {
    const filesResult = await this.listProjectFiles(projectId, userId);
    if (!filesResult.ok) {
      return { success: false, error: filesResult.error };
    }

    const matcher = this.buildPatternMatcher(pattern);
    const keywords = this.extractKeywords(taskDescription);

    const candidates = this.filterFiles(
      filesResult.value,
      matcher,
      keywords
    ).map((file) => file.path);

    if (candidates.length === 0) {
      // Fallback: If no specific matches, load README and package.json at minimum
      // This prevents empty context errors
      const defaults = ["README.md", "package.json"];
      return this.loadFiles(projectId, userId, defaults, maxFiles, maxSize);
    }

    return this.loadFiles(projectId, userId, candidates, maxFiles, maxSize);
  }

  private async listProjectFiles(
    projectId: string,
    userId: string
  ): Promise<ParseResult<FileSummary[]>> {
    const exclusions = EXCLUDED_PATHS.map(
      (pattern) => `-not -path "${pattern}"`
    ).join(" ");

    // ✅ UPDATED: Command now supports MAX_SCAN_RESULTS (2000)
    const command = `find . -type f ${exclusions} -printf '%s %p\\n' | head -${MAX_SCAN_RESULTS}`;

    const result = await SandboxService.execCommand(
      projectId,
      userId,
      command,
      30
    );

    if (result.status === "error") {
      return { ok: false, error: "Failed to scan project structure" };
    }

    const files: FileSummary[] = [];
    for (const line of result.stdout.split("\n").map((item) => item.trim())) {
      if (line.length === 0) {
        continue;
      }

      const separatorIndex = line.indexOf(" ");
      if (separatorIndex === -1) {
        continue;
      }

      const sizeValue = Number.parseInt(line.slice(0, separatorIndex), 10);
      const filePath = line.slice(separatorIndex + 1);

      if (Number.isNaN(sizeValue) || filePath.length === 0) {
        continue;
      }

      files.push({
        path: filePath,
        size: sizeValue,
        type: this.getFileType(filePath),
      });
    }

    return { ok: true, value: files };
  }

  private buildStructure(files: FileSummary[]): ProjectStructure {
    const directories = new Set<string>();
    let totalSize = 0;

    for (const file of files) {
      directories.add(path.dirname(file.path));
      totalSize += file.size;
    }

    return {
      directories: Array.from(directories).sort(),
      files,
      totalFiles: files.length,
      totalSize,
    };
  }

  private groupFilesByType(files: FileSummary[]): Record<string, number> {
    return files.reduce<Record<string, number>>((accumulator, file) => {
      accumulator[file.type] = (accumulator[file.type] ?? 0) + 1;
      return accumulator;
    }, {});
  }

  private getFileType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    if (!ext) {
      return "other";
    }

    const extension = ext.slice(1);
    if (["ts", "tsx", "js", "jsx"].includes(extension)) {
      return "typescript";
    }
    if (["json", "yaml", "yml", "toml"].includes(extension)) {
      return "config";
    }
    if (["md", "mdx", "txt"].includes(extension)) {
      return "docs";
    }
    if (["css", "scss", "sass", "less"].includes(extension)) {
      return "styles";
    }
    if (["png", "jpg", "jpeg", "gif", "svg", "ico"].includes(extension)) {
      return "assets";
    }
    return extension;
  }

  private async readWorkspaceFile(
    projectId: string,
    userId: string,
    filePath: string
  ): Promise<ParseResult<string>> {
    const result = await SandboxService.readFile(projectId, userId, filePath);
    if (result.status === "error" || typeof result.content !== "string") {
      return { ok: false, error: result.message ?? "Unable to read file" };
    }
    return { ok: true, value: result.content };
  }

  private safeJsonParse(content: string): Record<string, unknown> | null {
    try {
      const parsed: unknown = JSON.parse(content);
      return typeof parsed === "object" &&
        parsed !== null &&
        !Array.isArray(parsed)
        ? (parsed as Record<string, unknown>)
        : null;
    } catch (_error) {
      // Silent fail on parse error
      return null;
    }
  }

  private extractDependencies(
    json: Record<string, unknown>
  ): DependenciesSummary {
    const toDependencyList = (
      value: unknown
    ): Array<{ name: string; version?: string }> => {
      if (!this.isRecord(value)) {
        return [];
      }

      const dependencies: Array<{ name: string; version?: string }> = [];
      for (const name of Object.keys(value)) {
        const version = value[name];
        if (typeof version === "string") {
          dependencies.push({ name, version });
        }
      }
      return dependencies;
    };

    return {
      packages: toDependencyList(json.dependencies),
      devPackages: toDependencyList(json.devDependencies),
    };
  }

  private async loadJsonFile(
    projectId: string,
    userId: string,
    filePath: string
  ): Promise<Record<string, unknown> | null> {
    const fileResult = await this.readWorkspaceFile(
      projectId,
      userId,
      filePath
    );
    if (!fileResult.ok) {
      return null;
    }

    return this.safeJsonParse(fileResult.value);
  }

  private buildPatternMatcher(
    pattern: string | undefined
  ): ((filePath: string) => boolean) | null {
    if (!pattern) {
      return null;
    }

    let regexBody = "";
    for (let index = 0; index < pattern.length; index++) {
      const char = pattern[index];
      if (char === "*") {
        if (pattern[index + 1] === "*") {
          regexBody += ".*";
          index += 1;
        } else {
          regexBody += "[^/]*";
        }
        continue;
      }

      if (char === "?") {
        regexBody += ".";
        continue;
      }

      regexBody += char.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    try {
      const matcher = new RegExp(`^${regexBody}$`);
      return (filePath: string) => matcher.test(filePath);
    } catch (_error) {
      return null;
    }
  }

  private extractKeywords(taskDescription: string | undefined): string[] {
    if (!taskDescription) {
      return [];
    }
    return taskDescription
      .toLowerCase()
      .split(/[^a-z0-9]+/)
      .filter((keyword) => keyword.length >= 3);
  }

  private filterFiles(
    files: FileSummary[],
    matcher: ((filePath: string) => boolean) | null,
    keywords: string[]
  ): FileSummary[] {
    if (matcher) {
      return files.filter((file) => matcher(file.path));
    }

    if (keywords.length === 0) {
      return files;
    }

    // Prioritize files that match keywords in path
    return files.filter((file) => {
      const lowerPath = file.path.toLowerCase();
      return keywords.some((keyword) => lowerPath.includes(keyword));
    });
  }

  private isRecord(value: unknown): value is Record<string, unknown> {
    return typeof value === "object" && value !== null;
  }
}
