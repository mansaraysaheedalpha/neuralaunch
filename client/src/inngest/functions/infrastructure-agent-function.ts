// src/inngest/functions/infrastructure-agent-function.ts
/**
 * Infrastructure Agent Inngest Function
 * Triggered to set up Docker, env config, database, and CI/CD
 */

import { inngest } from "../client";
import { infrastructureAgent } from "@/lib/agents/infrastructure/infrastructure-agent";
import prisma from "@/lib/prisma";
import { logger } from "@/lib/logger";
import { createAgentError } from "@/lib/error-utils";
import { TechStack } from "@/lib/agents/types/common";

export const infrastructureAgentFunction = inngest.createFunction(
  {
    id: "infrastructure-agent-setup",
    name: "Infrastructure Agent - Setup Configuration",
    retries: 2,
  },
  { event: "agent/infrastructure.setup" },
  async ({ event, step }) => {
    const { taskId, projectId, userId, conversationId, taskInput } = event.data as {
      taskId: string;
      projectId: string;
      userId: string;
      conversationId: string;
      taskInput: {
        infrastructureType?: string;
        deploymentTarget?: string;
        databaseType?: string;
        includeRedis?: boolean;
        includeNginx?: boolean;
      };
    };

    logger.info(`[Inngest] Infrastructure Agent triggered`, {
      taskId,
      projectId,
      type: taskInput.infrastructureType || "all",
    });

    try {
      // Step 1: Get project context
      const projectContext = await step.run("get-project-context", async () => {
        return await prisma.projectContext.findUnique({
          where: { projectId },
          select: {
            techStack: true,
            architecture: true,
            codebase: true,
          },
        });
      });

      if (!projectContext) {
        throw new Error(`Project context not found for ${projectId}`);
      }

      // Step 2: Execute Infrastructure Agent
      const result = await step.run("setup-infrastructure", async () => {
        return await infrastructureAgent.execute({
          taskId: taskId,
          projectId,
          userId: userId,
          conversationId: conversationId,
          taskDetails: {
            title: "Infrastructure Setup",
            description: "Setup Docker, env config, database, and CI/CD",
            complexity: "medium",
            estimatedLines: 500,
            infrastructureType: taskInput.infrastructureType || "all",
            deploymentTarget: taskInput.deploymentTarget || "vercel",
            databaseType: taskInput.databaseType || "postgresql",
            includeRedis: taskInput.includeRedis || false,
            includeNginx: taskInput.includeNginx || false,
          },
          context: {
            techStack: projectContext.techStack as TechStack | undefined,
            architecture: projectContext.architecture,
          },
        });
      });

      // Step 3: Store results in database
      await step.run("store-infrastructure-results", async () => {
        // Update project context with infrastructure info
        await prisma.projectContext.update({
          where: { projectId },
          data: {
            codebase: {
              ...(projectContext.codebase as Record<string, unknown>),
              infrastructure: {
                docker: result.data?.docker || null,
                envConfig: result.data?.envConfig || null,
                database: result.data?.database || null,
                cicd: result.data?.cicd || null,
              },
            },
          },
        });

        logger.info(`[Inngest] Stored infrastructure config in ProjectContext`);
      });

      // Step 4: Commit infrastructure files to Git
      if (result.success && (result.data?.filesCreated as unknown[] | undefined)?.length) {
        await step.run("commit-infrastructure-files", async () => {
          const { GitTool } = await import("@/lib/agents/tools/git-tool");
          const gitTool = new GitTool();

          // Stage all files
          await gitTool.execute(
            { operation: "add" },
            { projectId, userId }
          );

          // Commit
          const commitMessage = `feat(infra): Setup infrastructure configuration

- Docker configuration (Dockerfile, docker-compose.yml)
- Environment variable templates (.env.example)
- Database migrations and seed scripts
- CI/CD pipeline (GitHub Actions)

Generated by Infrastructure Agent
Task ID: ${taskId}
Files: ${((result.data?.filesCreated as unknown[]) || []).join(", ")}`;

          await gitTool.execute(
            { operation: "commit", message: commitMessage },
            { projectId, userId }
          );

          logger.info(`[Inngest] Committed infrastructure files to Git`);
        });
      }

      // Step 5: Send completion event
      await step.run("send-completion-event", async () => {
        await inngest.send({
          name: "agent/infrastructure.setup.complete",
          data: {
            taskId,
            projectId,
            success: result.success,
            filesCreated: result.data?.filesCreated || [],
            configurations: result.data?.configurations || [],
          },
        });
      });

      logger.info(`[Inngest] Infrastructure Agent completed`, {
        taskId,
        success: result.success,
        filesCreated: result.data?.filesCreated?.length || 0,
      });

      return {
        success: result.success,
        message: result.message,
        filesCreated: result.data?.filesCreated || [],
        docker: result.data?.docker || null,
        envConfig: result.data?.envConfig || null,
        database: result.data?.database || null,
        cicd: result.data?.cicd || null,
      };
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error";

      logger.error(`[Inngest] Infrastructure Agent failed`, createAgentError(errorMessage, { taskId }));

      throw error;
    }
  }
);
